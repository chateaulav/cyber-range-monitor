from datetime import datetime
from collections import defaultdict
"""
helper functions for json manipulation
"""
def simplify_response(data, hostname):
    data = data['return'][0]
    data = data[hostname]
    return data

"""
parsing functions for specific pages 
"""


def group_jobs_by_target(jobs_data):
    """
    Args: jobs_data in simplified format

    Returns: nested dictionary of targets and their corresponding jobs
    """
    result = {}
    for job_id, job_details in jobs_data.items():
        targets = job_details.get('Target', [])
        if isinstance(targets, str):
            targets = [targets]
        for target in targets:
            result.setdefault(target, {})[job_id] = job_details
    return result


def sort_jobs_by_time(grouped_jobs):
    """
    Args: jobs_data after being grouped by target

    Returns: nested dictionary of targets and their corresponding jobs in chronological order
    """
    sorted_jobs = {}
    for target, jobs in grouped_jobs.items():
        sorted_jobs[target] = dict(
            sorted(
                jobs.items(),
                key=lambda x: datetime.strptime(x[1]['StartTime'], "%Y, %b %d %H:%M:%S.%f"),
                reverse=True
            )
        )
    return sorted_jobs


def clean_jobs(data):
    """
    Args: jobs_data in simplified format

    Returns: nested dictionary of jobs without functions generated by the monitor's api calls
    """
    # list of functions to remove from the data
    excluded_functions = {
        "saltutil.find_job", 
        "runner.jobs.list_jobs", 
        "test.ping", 
        "runner.manage.up",
        "grains.item"
    }
    cleaned_data = {
        job_id: job_info
        for job_id, job_info in data.items()
        if not any(
            func.startswith("monitor") or func in excluded_functions 
            for func in job_info.get("Function", "").split(',')
        )
    }
    return cleaned_data


def clean_minion_data(data):
    """
    Args: minion_data in simplified format

    Returns: dictionary of requested keys from minion grains.items() call
    """
    keys = ['id', 'virtual', 'uuid', 'build_phase', 'role', 'fqdn_ip4']
    if not data:
        return False
    return {
        minion_id: {key: grain_data[key] for key in keys if key in grain_data}
        for minion_id, grain_data in data.items()
    }


def get_physical_minions(data, hostname):
    """
    Args: return data from "salt * grains.item 'virtual'" api call, hostname of salt master

    Returns: list of minion ids that have virtual grain set to "physical"
    """
    if data is None:
        return []
    
    minion_ids = []
    data = data.get('return', [{}])[0].get(hostname, {})
    
    for minion_id, grain_data in data.items():
        if grain_data.get('virtual') == 'physical':
            minion_ids.append(minion_id)
    
    return minion_ids


def sort_minions_by_role(data):
    """
    Args: dictionary of minions and their grains data

    Returns: dictionary of minions and their grains data sorted alphabetically by role
    """
    sorted_data = defaultdict(list)
    for entry_id, entry in data.items():
        role = entry.get('role')
        if role is not None:
            sorted_data[role].append((entry_id, entry))
    return dict(sorted(sorted_data.items()))


def count_roles(data, hostname):
    """
    Args: return data from "manage.up" api call, hostname of salt master

    Returns: count of each type of minion, grouped by their role
    """
    role_counts = {}
    items= data['return'][0][hostname]

    for item in items:
        role = item.split('-')[0]
        if role in role_counts:
            role_counts[role] += 1
        else:
            role_counts[role] = 1
    
    x = list(role_counts.keys())
    y = list(role_counts.values())
    return {'x': x, 'y': y}